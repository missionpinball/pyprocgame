<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyprocgame Manual &mdash; pyprocgame  documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="pyprocgame  documentation" href="index.html" />
    <link rel="next" title="procgame Module Reference" href="ref-index.html" />
    <link rel="prev" title="Installation" href="install.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="ref-index.html" title="procgame Module Reference"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="install.html" title="Installation"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">pyprocgame  documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="pyprocgame-manual">
<h1>pyprocgame Manual<a class="headerlink" href="#pyprocgame-manual" title="Permalink to this headline">¶</a></h1>
<p>The P-ROC software architecture is divided into 3 layers:</p>
<ul class="simple">
<li>Layer 0: Serial interface to P-ROC USB.</li>
<li>Layer 1: libpinproc, C API to P-ROC.</li>
<li>Layer 2: High level ruleset development frameworks, such as pyprocgame.</li>
</ul>
<p>pyprocgame is a set of Python classes designed to provide a framework for implementing mode-based custom rulesets for pinball games.  The classes make responding to abritrary and non-trivial switch events easy, as well as providing support for displaying graphics and text on the pinball display (DMD).  pyprocgame is based on pypinproc, the Python wrapper for libpinproc.</p>
<div class="section" id="prerequisites">
<h2>Prerequisites<a class="headerlink" href="#prerequisites" title="Permalink to this headline">¶</a></h2>
<p>This guide is written with the assumption that you are familiar with <a class="reference external" href="http://en.wikipedia.org/wiki/Object-oriented_programming">object-oriented programming</a> and, to a lesser extent, the <a class="reference external" href="http://python.org">Python</a> programming language.  Terminology such as <em>object</em>, <em>class</em>, and <em>subclass</em> are used frequently within this guide and having a basic understanding of what those terms mean is important.  There is a significant amount of demo code available for pyprocgame; you should not hesitate to examine it or post to the appropriate forums if you have questions.</p>
</div>
<div class="section" id="what-s-in-pyprocgame">
<h2>What&#8217;s In pyprocgame<a class="headerlink" href="#what-s-in-pyprocgame" title="Permalink to this headline">¶</a></h2>
<p>pyprocgame provides a powerful set of classes to help you implement your game.  The following are the base classes which are used in every game:</p>
<ul class="simple">
<li><a class="reference internal" href="ref/game.html#procgame.game.GameController" title="procgame.game.GameController"><tt class="xref py py-class docutils literal"><span class="pre">GameController</span></tt></a> &#8211; The main game object, tying all of the objects together: modes, coils, lamps, switches, players, configuration, and the P-ROC hardware interface itself (pypinproc).  It also manages the run loop, which polls for switch and sends DMD updates.</li>
<li><a class="reference internal" href="ref/game.html#procgame.game.Mode" title="procgame.game.Mode"><tt class="xref py py-class docutils literal"><span class="pre">Mode</span></tt></a> &#8211; The Mode class is subclassed by you in order to implement the various modes of your game.  By defining method names that match a certain naming convention your mode can automatically respond to switch events that the game detects.</li>
<li><a class="reference internal" href="ref/game.html#procgame.game.ModeQueue" title="procgame.game.ModeQueue"><tt class="xref py py-class docutils literal"><span class="pre">ModeQueue</span></tt></a> &#8211; Modes are organized in the ModeQueue which is essentially a priority queue.  The ModeQueue handles notifying the active modes of switch events.  Higher priority modes receive switch events first and have the option of stopping the event from being propagated to lower priority modes.</li>
<li><a class="reference internal" href="ref/game.html#procgame.game.Player" title="procgame.game.Player"><tt class="xref py py-class docutils literal"><span class="pre">Player</span></tt></a> &#8211; Represents a player in the game with a score.</li>
<li><a class="reference internal" href="ref/game.html#procgame.game.Switch" title="procgame.game.Switch"><tt class="xref py py-class docutils literal"><span class="pre">Switch</span></tt></a> &#8211; Abstraction of a hardware switch in the game, with active and inactive state.</li>
<li><a class="reference internal" href="ref/game.html#procgame.game.Driver" title="procgame.game.Driver"><tt class="xref py py-class docutils literal"><span class="pre">Driver</span></tt></a> &#8211; Abstraction of a hardware driver, such as a lamp, coil/solenoid, or flasher.</li>
</ul>
<p>In addition, pyprocgame provides a number of classes to make controlling the dot matrix display (DMD) of your game much easier:</p>
<ul class="simple">
<li><a class="reference internal" href="ref/dmd.html#procgame.dmd.DisplayController" title="procgame.dmd.DisplayController"><tt class="xref py py-class docutils literal"><span class="pre">DisplayController</span></tt></a> &#8211; Manages the DMD by assembling the currently displayed frame from the active modes on the mode queue.</li>
<li><tt class="xref py py-class docutils literal"><span class="pre">ScoreDisplay</span></tt> &#8211; Makes providing a classic 4-player score display extremely easy.  ScoreDisplay is implemented as a Mode that generates a DMD Frame on demand (usually to DisplayController).</li>
<li><a class="reference internal" href="ref/dmd.html#procgame.dmd.Frame" title="procgame.dmd.Frame"><tt class="xref py py-class docutils literal"><span class="pre">Frame</span></tt></a> &#8211; A single DMD bitmap, usually 128x32.</li>
<li><a class="reference internal" href="ref/dmd.html#procgame.dmd.Animation" title="procgame.dmd.Animation"><tt class="xref py py-class docutils literal"><span class="pre">Animation</span></tt></a> &#8211; A collection of DMD frames.</li>
<li><a class="reference internal" href="ref/dmd.html#procgame.dmd.Font" title="procgame.dmd.Font"><tt class="xref py py-class docutils literal"><span class="pre">Font</span></tt></a> &#8211; A bitmap font for use with the DMD.</li>
<li><a class="reference internal" href="ref/dmd.html#procgame.dmd.Layer" title="procgame.dmd.Layer"><tt class="xref py py-class docutils literal"><span class="pre">Layer</span></tt></a> &#8211; An abstract class; provides a sequence of DMD Frames.</li>
<li><a class="reference internal" href="ref/dmd.html#procgame.dmd.GroupedLayer" title="procgame.dmd.GroupedLayer"><tt class="xref py py-class docutils literal"><span class="pre">GroupedLayer</span></tt></a>, <a class="reference internal" href="ref/dmd.html#procgame.dmd.ScriptedLayer" title="procgame.dmd.ScriptedLayer"><tt class="xref py py-class docutils literal"><span class="pre">ScriptedLayer</span></tt></a>, <a class="reference internal" href="ref/dmd.html#procgame.dmd.AnimatedLayer" title="procgame.dmd.AnimatedLayer"><tt class="xref py py-class docutils literal"><span class="pre">AnimatedLayer</span></tt></a>, <a class="reference internal" href="ref/dmd.html#procgame.dmd.FrameLayer" title="procgame.dmd.FrameLayer"><tt class="xref py py-class docutils literal"><span class="pre">FrameLayer</span></tt></a>, <a class="reference internal" href="ref/dmd.html#procgame.dmd.TextLayer" title="procgame.dmd.TextLayer"><tt class="xref py py-class docutils literal"><span class="pre">TextLayer</span></tt></a> &#8211; Implementations of the Layer class that provide the building blocks necessary to build sophisticated displays.</li>
</ul>
<p>These classes will be described in greater depth in the sections that follow.</p>
</div>
<div class="section" id="what-s-in-a-pyprocgame-game">
<h2>What&#8217;s in a pyprocgame Game?<a class="headerlink" href="#what-s-in-a-pyprocgame-game" title="Permalink to this headline">¶</a></h2>
<p>Fortunately you won&#8217;t need to understand all of those classes in order to build a pinball game with pyprocgame, but you will need is a basic understanding of how the <a class="reference internal" href="ref/game.html#procgame.game.GameController" title="procgame.game.GameController"><tt class="xref py py-class docutils literal"><span class="pre">GameController</span></tt></a> and <a class="reference internal" href="ref/game.html#procgame.game.ModeQueue" title="procgame.game.ModeQueue"><tt class="xref py py-class docutils literal"><span class="pre">ModeQueue</span></tt></a> work.</p>
<p>Let&#8217;s look at a ridiculously simple game implemented with pyprocgame:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">pinproc</span>
<span class="kn">import</span> <span class="nn">procgame.game</span>
<span class="n">game</span> <span class="o">=</span> <span class="n">procgame</span><span class="o">.</span><span class="n">game</span><span class="o">.</span><span class="n">GameController</span><span class="p">(</span><span class="n">machine_type</span><span class="o">=</span><span class="n">pinproc</span><span class="o">.</span><span class="n">MachineTypeWPC</span><span class="p">)</span>
<span class="n">game</span><span class="o">.</span><span class="n">load_config</span><span class="p">(</span><span class="s">&#39;mygame.yaml&#39;</span><span class="p">)</span>
<span class="n">game</span><span class="o">.</span><span class="n">enable_flippers</span><span class="p">(</span><span class="n">enable</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">game</span><span class="o">.</span><span class="n">run_loop</span><span class="p">()</span>
</pre></div>
</div>
<p>This particular game isn&#8217;t particularly deep, but it&#8217;s a good way to demonstrate what a pyprocgame program looks like from the very highest level.  Let&#8217;s see what&#8217;s happening line-by-line:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">pinproc</span>
</pre></div>
</div>
<p>Our first step is to import the pinproc module, which contains some useful constants. It also contains a lower-level interface to the P-ROC, which pyprocgame relies upon.</p>
<blockquote>
<div>import procgame.game</div></blockquote>
<p>Next we&#8217;ll import the procgame.game module, which contains higher level classes used by most games.  This particular program assumes that pyprocgame is in your sys.path.  If it&#8217;s not, you will need to modify sys.path.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">game</span> <span class="o">=</span> <span class="n">procgame</span><span class="o">.</span><span class="n">game</span><span class="o">.</span><span class="n">GameController</span><span class="p">(</span><span class="n">machine_type</span><span class="o">=</span><span class="n">pinproc</span><span class="o">.</span><span class="n">MachineTypeWPC</span><span class="p">)</span>
</pre></div>
</div>
<p>Next we create a new <a class="reference internal" href="ref/game.html#procgame.game.GameController" title="procgame.game.GameController"><tt class="xref py py-class docutils literal"><span class="pre">GameController</span></tt></a> object.  This is the central object in your pinball game.  It maintains collections for all of the switches, lamps and coils, as well as players in the current game.  It also contains a <a class="reference internal" href="ref/game.html#procgame.game.ModeQueue" title="procgame.game.ModeQueue"><tt class="xref py py-class docutils literal"><span class="pre">ModeQueue</span></tt></a>, which we&#8217;ll cover later.  (If this were an actual full-blown pyprocgame program we would create our own subclass of <a class="reference internal" href="ref/game.html#procgame.game.GameController" title="procgame.game.GameController"><tt class="xref py py-class docutils literal"><span class="pre">GameController</span></tt></a>.)</p>
<p>Note that the connection to the P-ROC hardware is established in the constructor for <a class="reference internal" href="ref/game.html#procgame.game.GameController" title="procgame.game.GameController"><tt class="xref py py-class docutils literal"><span class="pre">GameController</span></tt></a> and the hardware is reset to obtain a known state.  We pass the <tt class="docutils literal"><span class="pre">machine_type</span></tt> value as <tt class="docutils literal"><span class="pre">'wpc'</span></tt> in order to initialize P-ROC to the proper settings for controlling a WPC driver board.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">game</span><span class="o">.</span><span class="n">load_config</span><span class="p">(</span><span class="s">&#39;mygame.yaml&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here we load a YAML file that describes the pinball hardware.  The P-ROC software uses YAML files (a &#8220;human-friendly data serialization standard&#8221;) to describe the machine that the P-ROC hardware is connected to (see <a class="reference internal" href="#machine-config"><em>Machine Configuration Files</em></a> for a complete description of these files).  This statement loads the configuration and configures all of the switches, lamps and coils, as well as the flippers so that we can...</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">game</span><span class="o">.</span><span class="n">enable_flippers</span><span class="p">(</span><span class="n">enable</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>It wouldn&#8217;t be pinball without flippers; here&#8217;s where we turn them on.  The pyprocgame code behind this statement uses the machine description (from the YAML file previously loaded with <a class="reference internal" href="ref/game.html#procgame.game.GameController.load_config" title="procgame.game.GameController.load_config"><tt class="xref py py-meth docutils literal"><span class="pre">load_config()</span></tt></a>) to create the association between the flipper buttons (switches) and the flipper coils.</p>
<p>Internally, this takes advantage of P-ROC&#8217;s switch rules feature, which enables a hardware-triggered linkage between switch events and coil drivers to guarantee that when the player hits the flipper button the coil will be fired immediately.  This keeps P-ROC-based games responsive, rather than suffering from any latency between the computer host processing of the switch event and activating the coil driver.  The same principle can be applied to pop bumpers.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">game</span><span class="o">.</span><span class="n">run_loop</span><span class="p">()</span>
</pre></div>
</div>
<p>Finally we start the game&#8217;s run loop, which allows the game to actually run.  The run loop checks for events from the P-ROC hardware and sends them to the <a class="reference internal" href="ref/game.html#procgame.game.ModeQueue" title="procgame.game.ModeQueue"><tt class="xref py py-class docutils literal"><span class="pre">ModeQueue</span></tt></a> so that they can be responded to by your game code.  This method call is blocking and does not return until program execution is interrupted (usually by a Ctrl-C).</p>
</div>
<div class="section" id="onward-to-deeper-rulesets">
<h2>Onward to Deeper Rulesets<a class="headerlink" href="#onward-to-deeper-rulesets" title="Permalink to this headline">¶</a></h2>
<p>Most pinball games are a bit more sophisticated than just hitting the flippers.  You usually have targets to hit, banks of drop targets to knock down, and so on.  In the abstract those features seem pretty easy to implement: respond to the switch event and award points.  But what about more complex rulesets?  Multiball?  <em>Stacked</em> multiballs?  Things can get complicated quickly!</p>
<p>When we were designing pyprocgame our goal was to enable the developer (that&#8217;s you) to create rulesets that are as complicated as they can imagine while keeping the task of implementing (and debugging) those rulesets as sane as possible.  Just like you, we want to design our own games, and we want to have fun doing it.</p>
<p>To reiterate the above, we designed pyprocgame to be flexible enough to allow you to create any game ruleset you can imagine, yet provide enough of a framework to help you get off the ground quickly.  We&#8217;ve strived to keep the features modular and limit interdependence so that if, for example, you want to write your own routines to control the DMD you can do so, or if you want to create your own mode system you can replace ours and still take advantage of the Python interface to libpinproc and the DMD utilities.</p>
</div>
<div class="section" id="modes-and-the-modequeue">
<h2>Modes and the ModeQueue<a class="headerlink" href="#modes-and-the-modequeue" title="Permalink to this headline">¶</a></h2>
<p>We&#8217;ve been talking about pyprocgame at a very high level, but let&#8217;s get down to specifics for a moment:</p>
<p>Mode objects are the building blocks of pyprocgame games.  In pyrpocgame a mode is <em>a functional subset of a game that receives switch events</em>.   When active, modes are organized in a queue (<a class="reference internal" href="ref/game.html#procgame.game.ModeQueue" title="procgame.game.ModeQueue"><tt class="xref py py-class docutils literal"><span class="pre">ModeQueue</span></tt></a>), which determines the order in which they receive switch events.  That is, when the <a class="reference internal" href="ref/game.html#procgame.game.GameController" title="procgame.game.GameController"><tt class="xref py py-class docutils literal"><span class="pre">GameController</span></tt></a>&#8216;s <a class="reference internal" href="ref/game.html#procgame.game.GameController.run_loop" title="procgame.game.GameController.run_loop"><tt class="xref py py-meth docutils literal"><span class="pre">run_loop()</span></tt></a> receives a switch event from the P-ROC hardware, only objects in the <a class="reference internal" href="ref/game.html#procgame.game.ModeQueue" title="procgame.game.ModeQueue"><tt class="xref py py-class docutils literal"><span class="pre">ModeQueue</span></tt></a> will be notified of the event.  If you want your game to react to a switch event, one or more of your modes must be given that responsibility.</p>
<p>We subclass <a class="reference internal" href="ref/game.html#procgame.game.Mode" title="procgame.game.Mode"><tt class="xref py py-class docutils literal"><span class="pre">Mode</span></tt></a> to create our own useful modes.  Let&#8217;s look at a simple mode:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">FirstMode</span><span class="p">(</span><span class="n">procgame</span><span class="o">.</span><span class="n">game</span><span class="o">.</span><span class="n">Mode</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">FirstMode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">game</span><span class="o">=</span><span class="n">game</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">sw_startButton_active</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sw</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;Start!&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">procgame</span><span class="o">.</span><span class="n">game</span><span class="o">.</span><span class="n">SwitchStop</span>
</pre></div>
</div>
<p>Here we have defined a class, <tt class="xref py py-class docutils literal"><span class="pre">FirstMode</span></tt>, which subclasses the procgame <a class="reference internal" href="ref/game.html#procgame.game.Mode" title="procgame.game.Mode"><tt class="xref py py-class docutils literal"><span class="pre">Mode</span></tt></a> class.  The <a class="reference internal" href="ref/game.html#procgame.game.Mode" title="procgame.game.Mode"><tt class="xref py py-class docutils literal"><span class="pre">Mode</span></tt></a> constructor takes 2 parameters.  <tt class="docutils literal"><span class="pre">game</span></tt> is a reference to an instance of our own <a class="reference internal" href="ref/game.html#procgame.game.GameController" title="procgame.game.GameController"><tt class="xref py py-class docutils literal"><span class="pre">GameController</span></tt></a> subclass, and <tt class="docutils literal"><span class="pre">priority</span></tt> governs the order in which this mode will receive events, relative to the others – more on that later.</p>
<p>Next we define a method with a rather distinctive name: <tt class="docutils literal"><span class="pre">sw_startButton_active()</span></tt>.  This is our switch event handler.  When a <a class="reference internal" href="ref/game.html#procgame.game.Mode" title="procgame.game.Mode"><tt class="xref py py-class docutils literal"><span class="pre">Mode</span></tt></a> is instantiated its method list is scanned for methods that match a certain naming pattern: <tt class="docutils literal"><span class="pre">sw_(switch</span> <span class="pre">name)_active</span></tt> in this case.  This tells pyprocgame that it should call this method when the button named <tt class="docutils literal"><span class="pre">startButton</span></tt> is active (closed in this case; this is configurable for each switch using the YAML file).</p>
<p>Similarly, a method named <tt class="docutils literal"><span class="pre">sw_trainWreck_inactive()</span></tt> would be called when the trainWreck switch had changed to an inactive state.  The switch name in these method names must correspond to a switch name in the YAML configuration; otherwise a warning message will be printed when instantiating the class.  More on switch even handlers (including responding to events after a delay) later.</p>
<p>Our switch handler in this case is very simple.  It prints out a message and returns <tt class="xref py py-data docutils literal"><span class="pre">procgame.game.SwitchStop</span></tt>.  Each switch event handler must return <tt class="xref py py-data docutils literal"><span class="pre">SwitchStop</span></tt> or <tt class="xref py py-data docutils literal"><span class="pre">SwitchContinue</span></tt>.  A return value of stop instructs <a class="reference internal" href="ref/game.html#procgame.game.ModeQueue" title="procgame.game.ModeQueue"><tt class="xref py py-class docutils literal"><span class="pre">ModeQueue</span></tt></a> to stop processing this event; a return value of continue tells the <a class="reference internal" href="ref/game.html#procgame.game.ModeQueue" title="procgame.game.ModeQueue"><tt class="xref py py-class docutils literal"><span class="pre">ModeQueue</span></tt></a> to allow this switch event to be sent to other active modes.  If you do not explicitly return a value from a switch handler method the behavior will be the same as if <tt class="xref py py-data docutils literal"><span class="pre">SwitchContinue</span></tt> had been returned.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Previously switch handlers returned <tt class="docutils literal"><span class="pre">True</span></tt> or <tt class="docutils literal"><span class="pre">False</span></tt> to indicate <tt class="xref py py-data docutils literal"><span class="pre">SwitchStop</span></tt> or <tt class="xref py py-data docutils literal"><span class="pre">SwitchContinue</span></tt>, respectively.  This practice has been superseded by these constants for clarity.  They are backward compatible.</p>
</div>
<p>This is where the priority of a mode becomes important.  The <a class="reference internal" href="ref/game.html#procgame.game.ModeQueue" title="procgame.game.ModeQueue"><tt class="xref py py-class docutils literal"><span class="pre">ModeQueue</span></tt></a> is essentially a priority queue: the highest-priority modes receive switch events first.  If the switch handler returns continue the switch event is then sent to lower priority modes.  In this way you can use a high priority mode to give switches on the playfield to have special meaning during any number of modes, without having to handle that special case alongside the code for the more normal meaning of the switch.  Or you can easily have a switch result in multiple mode triggers.</p>
<div class="section" id="mode-management">
<h3>Mode Management<a class="headerlink" href="#mode-management" title="Permalink to this headline">¶</a></h3>
<p>Now that we have a mode, how do we add it to the <a class="reference internal" href="ref/game.html#procgame.game.ModeQueue" title="procgame.game.ModeQueue"><tt class="xref py py-class docutils literal"><span class="pre">ModeQueue</span></tt></a> so that it will receive events?  Let&#8217;s create a more mature example game by subclassing <a class="reference internal" href="ref/game.html#procgame.game.GameController" title="procgame.game.GameController"><tt class="xref py py-class docutils literal"><span class="pre">GameController</span></tt></a>, assuming our <tt class="xref py py-class docutils literal"><span class="pre">FirstMode</span></tt> class is defined elsewhere in the file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">ExampleGame</span><span class="p">(</span><span class="n">procgame</span><span class="o">.</span><span class="n">game</span><span class="o">.</span><span class="n">GameController</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">machine_type</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">ExampleGame</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">machine_type</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">load_config</span><span class="p">(</span><span class="s">&#39;mygame.yaml&#39;</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">ExampleGame</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
    <span class="n">first_mode</span> <span class="o">=</span> <span class="n">FirstMode</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">first_mode</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">enable_flippers</span><span class="p">(</span><span class="n">enable</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">game</span> <span class="o">=</span> <span class="n">ExampleGame</span><span class="p">(</span><span class="n">machine_type</span><span class="o">=</span><span class="s">&#39;wpc&#39;</span><span class="p">)</span>
<span class="n">game</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
<span class="n">game</span><span class="o">.</span><span class="n">run_loop</span><span class="p">()</span>
</pre></div>
</div>
<p>We&#8217;ve reorganized the code a bit to reflect the recommended layout for pyprocgame games.  First we moved the configuration loading to the constructor, and added an override for <tt class="xref py py-meth docutils literal"><span class="pre">procgame.game.GameController.reset()</span></tt>, which is called to reset the state of the game and the hardware.  Because the <a class="reference internal" href="ref/game.html#procgame.game.ModeQueue" title="procgame.game.ModeQueue"><tt class="xref py py-class docutils literal"><span class="pre">ModeQueue</span></tt></a> (self.modes in this context &#8211; every <a class="reference internal" href="ref/game.html#procgame.game.GameController" title="procgame.game.GameController"><tt class="xref py py-class docutils literal"><span class="pre">GameController</span></tt></a> has a <a class="reference internal" href="ref/game.html#procgame.game.ModeQueue" title="procgame.game.ModeQueue"><tt class="xref py py-class docutils literal"><span class="pre">ModeQueue</span></tt></a> at self.modes) is cleared by <tt class="xref py py-meth docutils literal"><span class="pre">reset()</span></tt>, we can simply add an instance of our mode at this point.</p>
</div>
<div class="section" id="other-mode-features">
<h3>Other Mode Features<a class="headerlink" href="#other-mode-features" title="Permalink to this headline">¶</a></h3>
<div class="section" id="timed-switch-handlers">
<h4>Timed Switch Handlers<a class="headerlink" href="#timed-switch-handlers" title="Permalink to this headline">¶</a></h4>
<p>In some cases you may wish to respond to a switch event only after the switch has been in that state for a certain time period.  The Mode class provides a means for accomplishing this with incredible ease &#8211; just add a <tt class="docutils literal"><span class="pre">_for_(time</span> <span class="pre">period)_</span></tt> suffix to the normal switch method convention:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">sw_switchName_active_for_500ms()</span></tt> &#8211; called once switchName is active for 500 milliseconds</li>
<li><tt class="docutils literal"><span class="pre">sw_switchName_inactive_for_3s()</span></tt> &#8211; called once switchName is inactive for 3 seconds</li>
<li><tt class="docutils literal"><span class="pre">sw_switchName_inactive_for_20ms()</span></tt> &#8211; called once switchName is inactive for 20 milliseconds</li>
</ul>
</div>
<div class="section" id="scheduling-delayed-method-calls">
<h4>Scheduling Delayed Method Calls<a class="headerlink" href="#scheduling-delayed-method-calls" title="Permalink to this headline">¶</a></h4>
<p>You can schedule a method to be called after a specified delay using <a class="reference internal" href="ref/game.html#procgame.game.Mode.delay" title="procgame.game.Mode.delay"><tt class="xref py py-meth docutils literal"><span class="pre">procgame.game.Mode.delay()</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">sw_target1_active</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sw</span><span class="p">):</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">delay</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">delayed_event</span><span class="p">)</span>
  <span class="k">return</span> <span class="bp">True</span>

<span class="k">def</span> <span class="nf">delayed_target</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="k">print</span><span class="p">(</span><span class="s">&quot;It&#39;s been 500 milliseconds!&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>If you want to cancel a delay at a later time, store the return value from <tt class="xref py py-meth docutils literal"><span class="pre">delay()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">sw_target1_active</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sw</span><span class="p">):</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">delayed_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delay</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">delayed_event</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">sw_target2_active</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sw</span><span class="p">):</span>
  <span class="c"># Cancel the previously-scheduled delay:</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">cancel_delayed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delayed_name</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">delayed_target</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="k">print</span><span class="p">(</span><span class="s">&quot;It&#39;s been 500 milliseconds!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="mode-status-methods">
<h4>Mode Status Methods<a class="headerlink" href="#mode-status-methods" title="Permalink to this headline">¶</a></h4>
<p>Mode subclasses can also implement the following methods to receive and respond to changes in state:</p>
<ul class="simple">
<li><a class="reference internal" href="ref/game.html#procgame.game.Mode.mode_started" title="procgame.game.Mode.mode_started"><tt class="xref py py-meth docutils literal"><span class="pre">mode_started()</span></tt></a> &#8211; Called when the mode is added to the ModeQueue.</li>
<li><a class="reference internal" href="ref/game.html#procgame.game.Mode.mode_stopped" title="procgame.game.Mode.mode_stopped"><tt class="xref py py-meth docutils literal"><span class="pre">mode_stopped()</span></tt></a> &#8211; Called when the mode is removed from the ModeQueue.</li>
<li><a class="reference internal" href="ref/game.html#procgame.game.Mode.mode_topmost" title="procgame.game.Mode.mode_topmost"><tt class="xref py py-meth docutils literal"><span class="pre">mode_topmost()</span></tt></a> &#8211; Called when the mode is the mode with the highest priority on the ModeQueue, and therefore the first to receive all switch events.</li>
<li><a class="reference internal" href="ref/game.html#procgame.game.Mode.mode_tick" title="procgame.game.Mode.mode_tick"><tt class="xref py py-meth docutils literal"><span class="pre">mode_tick()</span></tt></a> &#8211; Called each time the run_loop() completes one &#8216;cycle&#8217; of reading events and processing them.  This method will be called many, many times per second on every mode in the mode queue and so should be brief in order to keep the run loop running quickly.</li>
</ul>
</div>
</div>
<div class="section" id="thoughts-on-planning-and-design-of-modes">
<h3>Thoughts on Planning and Design of Modes<a class="headerlink" href="#thoughts-on-planning-and-design-of-modes" title="Permalink to this headline">¶</a></h3>
<p>Modes can be very course-grained, such as a mode that controls all of multiball from start to finish (Multiball), or very fine-grained (MultiballActivate, MultiballRunning, MultiballJackpot, MultiballRestart).  It&#8217;s up to you to determine how you want to lay out your modes.</p>
<p>Additionally, it&#8217;s important to note that modes do not need to correspond to modes on your playfield.  You can create a Mode subclass and add it to the <a class="reference internal" href="ref/game.html#procgame.game.ModeQueue" title="procgame.game.ModeQueue"><tt class="xref py py-class docutils literal"><span class="pre">ModeQueue</span></tt></a> and use it for all sorts of things within your game: displays, timers, visual effects, service mode, initial entry, and so on.</p>
</div>
</div>
<div class="section" id="drivers">
<h2>Drivers<a class="headerlink" href="#drivers" title="Permalink to this headline">¶</a></h2>
<p>We&#8217;ve spent a good amount of time talking about how to react to events within the game, but a huge part of pinball is affecting changes within the game: powering coils, turning lamps on and off, and pulsing flashers.  Once you have a fleshed out YAML file for your machine, you can easily control individual elements of the game by accessing them within the GameController subclass.  Since you&#8217;ll usually be making these changes from within switch handlers, we&#8217;ll show the examples in that context:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">sw_someButton_active</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sw</span><span class="p">):</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">game</span><span class="o">.</span><span class="n">lamps</span><span class="o">.</span><span class="n">startButton</span><span class="o">.</span><span class="n">schedule</span><span class="p">(</span><span class="n">schedule</span><span class="o">=</span><span class="mh">0xff00ff00</span><span class="p">,</span>
    <span class="n">cycle_seconds</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">now</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

  <span class="bp">self</span><span class="o">.</span><span class="n">game</span><span class="o">.</span><span class="n">coils</span><span class="o">.</span><span class="n">popper</span><span class="o">.</span><span class="n">pulse</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>

  <span class="bp">self</span><span class="o">.</span><span class="n">game</span><span class="o">.</span><span class="n">lamps</span><span class="o">.</span><span class="n">shootAgain</span><span class="o">.</span><span class="n">pulse</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c"># Turn on indefinitely.</span>
</pre></div>
</div>
</div>
<div class="section" id="configuration-files">
<h2>Configuration Files<a class="headerlink" href="#configuration-files" title="Permalink to this headline">¶</a></h2>
<p>pyprocgame uses configuration files in the <a class="reference external" href="http://yaml.org/">YAML</a> format.  YAML is a human-readable structured text file format.  Configuration files generally consist of a set of &#8220;keys&#8221; at the top level</p>
<div class="section" id="machine-configuration-files">
<span id="machine-config"></span><h3>Machine Configuration Files<a class="headerlink" href="#machine-configuration-files" title="Permalink to this headline">¶</a></h3>
<p>Machine configuration files describe the physical components of a pinball machine: coils, lamps, switches, etc., and make it easier to refer to those components in code.  The following is a subset a machine configuration file for Judge Dredd (JD.yaml):</p>
<div class="highlight-python"><div class="highlight"><pre>PRGame:
  machineType: wpc
  numBalls: 6
PRFlippers:
  - flipperLwR
  - flipperLwL
PRBumpers:
  - slingL
PRSwitches:
  flipperLwR:
    number: SF2
  flipperLwL:
    number: SF4
  leftRampToLock:
    number: S63
    type: &#39;NC&#39;
PRCoils:
  flipperLwRMain:
    number: FLRM
PRLamps:
  perp1W:
    number: L11
  perp1R:
    number: L12
</pre></div>
</div>
</div>
<div class="section" id="system-configuration-files">
<span id="system-config"></span><h3>System Configuration Files<a class="headerlink" href="#system-configuration-files" title="Permalink to this headline">¶</a></h3>
<p>System configuration files contain values common to all games, and values specific to the system being developed on, such as file paths.  The configuration file is managed by the <tt class="xref py py-mod docutils literal"><span class="pre">procgame.config</span></tt> module; you can retrieve values from the configuration using <a class="reference internal" href="ref/config.html#procgame.config.value_for_key_path" title="procgame.config.value_for_key_path"><tt class="xref py py-func docutils literal"><span class="pre">value_for_key_path()</span></tt></a>.</p>
<p>The configuration file is located at <tt class="docutils literal"><span class="pre">~/.pyprocgame/config.yaml</span></tt>.  Note that the tilde (~) is a UNIX convention meaning the user&#8217;s home directory.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Windows Users</p>
<p>On Windows it can be tricky to determine your home directory.  Luckily pyprocgame prints out the full path that it expects to find the config.yaml file at.  Make sure that the path that pyprocgame prints matches where you placed your configuration file.</p>
<p>If you encounter difficulty creating a <tt class="docutils literal"><span class="pre">.pyprocgame</span></tt> directory in Windows, try using the command print: <tt class="docutils literal"><span class="pre">mkdir</span> <span class="pre">.pyprocgame</span></tt>.  Yes, that&#8217;s &#8220;dot-pyprocgame&#8221;.  Dot-files and dot-folders are common in UNIX-like systems.  By default they are not shown in directory listings.</p>
<p class="last">When creating your config.yaml file, be sure that its actual extension is <tt class="docutils literal"><span class="pre">.yaml</span></tt>, not <tt class="docutils literal"><span class="pre">.txt</span></tt>.  Some components of Windows like to add a <tt class="docutils literal"><span class="pre">.txt</span></tt> extension when you are not expecting it.</p>
</div>
<p>An example config.yaml file follows:</p>
<div class="highlight-python"><div class="highlight"><pre>font_path:
 - ~/Projects/PROC/shared/dmd
 - ~/Projects/PROC/my_fonts
config_path:
 - ~/Projects/PROC/shared/config
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">font_path</span></tt> is used by <a class="reference internal" href="ref/dmd.html#procgame.dmd.font_named" title="procgame.dmd.font_named"><tt class="xref py py-func docutils literal"><span class="pre">font_named()</span></tt></a>, while <tt class="docutils literal"><span class="pre">config_path</span></tt> is used by <tt class="xref py py-func docutils literal"><span class="pre">config_named()</span></tt>.</p>
</div>
</div>
<div class="section" id="dot-matrix-display-dmd-control">
<h2>Dot Matrix Display (DMD) Control<a class="headerlink" href="#dot-matrix-display-dmd-control" title="Permalink to this headline">¶</a></h2>
<div class="section" id="pyprocgame-display-architecture">
<h3>pyprocgame Display Architecture<a class="headerlink" href="#pyprocgame-display-architecture" title="Permalink to this headline">¶</a></h3>
<p>There are a lot of different ways one could run a DMD with pyprocgame, but here we&#8217;re going to talk about the recommended approach, which is well-integrated with the mode queue system.  Let&#8217;s talk about how the P-ROC hardware works first.  The P-ROC board provides a three hardware frame buffers, displaying them in order as new frames are provided by the software.  This helps keep the display smooth to avoid hiccups caused by operating system scheduling variances.  Much like a switch event, P-ROC sends a DMD event when it&#8217;s ready to display another frame.  So if we send the next frame whenever we see this event, we can keep P-ROC&#8217;s frame buffers full and maintain smooth, skipless video.</p>
<p>The <a class="reference internal" href="ref/dmd.html#procgame.dmd.DisplayController" title="procgame.dmd.DisplayController"><tt class="xref py py-class docutils literal"><span class="pre">DisplayController</span></tt></a> class makes this pretty easy.  Here&#8217;s how we incorporate it into our <tt class="xref py py-class docutils literal"><span class="pre">GameController</span></tt> subclass:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">DemoGame</span><span class="p">(</span><span class="n">game</span><span class="o">.</span><span class="n">GameController</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">machine_type</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">DemoGame</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">machine_type</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dmd</span> <span class="o">=</span> <span class="n">dmd</span><span class="o">.</span><span class="n">DisplayController</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">dmd_event</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dmd</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
</pre></div>
</div>
<p>That&#8217;s great, but how do we tell the <tt class="xref py py-class docutils literal"><span class="pre">DisplayController</span></tt> what to display?  Every time <a class="reference internal" href="ref/dmd.html#procgame.dmd.DisplayController.update" title="procgame.dmd.DisplayController.update"><tt class="xref py py-meth docutils literal"><span class="pre">DisplayController.update()</span></tt></a> is called it traverses the mode queue and asks each mode if it has a DMD frame to display.  If it does, it composites it upon the frames of lower priority modes.  Once it has the final frame assembled it is uploaded to the P-ROC hardware.</p>
<p>Note the order in which the frames are composited: <em>frames from lower priority modes are overwritten by higher priority frames</em>.  So imagine that you have laid out your modes like this:</p>
<blockquote>
<div><ul class="simple">
<li>Priority 1 (low): General game play mode.  Provides a frame showing the score.</li>
<li>Priority 5 (medium): &#8220;Hurry-up&#8221; mode.  Provides a frame showing the hurry-up countdown and jackpot value.</li>
</ul>
</div></blockquote>
<p>If you&#8217;ve been thinking about how you&#8217;d organize your modes already, this is the sort of pattern that you should follow for switch events.  More specialized modes get first crack at the switch events due to their priority.  This pattern also works well with <tt class="xref py py-class docutils literal"><span class="pre">DisplayController</span></tt>: the hurry-up information is shown to the player when that mode is active; otherwise the score is shown.</p>
<p>How does the mode supply the DMD frame to <tt class="xref py py-class docutils literal"><span class="pre">DisplayController</span></tt>, though?  To explain that we first need to introduce the Layer class, which provides a sequence of frames via its method <a class="reference internal" href="ref/dmd.html#procgame.dmd.Layer.next_frame" title="procgame.dmd.Layer.next_frame"><tt class="xref py py-meth docutils literal"><span class="pre">next_frame()</span></tt></a>.  There are a number of useful <a class="reference internal" href="ref/dmd.html#procgame.dmd.Layer" title="procgame.dmd.Layer"><tt class="xref py py-class docutils literal"><span class="pre">Layer</span></tt></a> subclasses provided with pyprocgame:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="ref/dmd.html#procgame.dmd.FrameLayer" title="procgame.dmd.FrameLayer"><tt class="xref py py-class docutils literal"><span class="pre">FrameLayer</span></tt></a>: Provides an endless sequence of one frame (dmd.Frame).</li>
<li><a class="reference internal" href="ref/dmd.html#procgame.dmd.AnimatedLayer" title="procgame.dmd.AnimatedLayer"><tt class="xref py py-class docutils literal"><span class="pre">AnimatedLayer</span></tt></a>: Provides an ordered sequence of dmd.Frame objects.</li>
<li><a class="reference internal" href="ref/dmd.html#procgame.dmd.TextLayer" title="procgame.dmd.TextLayer"><tt class="xref py py-class docutils literal"><span class="pre">TextLayer</span></tt></a>: Uses a dmd.Font to display a text string to the user.</li>
<li><a class="reference internal" href="ref/dmd.html#procgame.dmd.GroupedLayer" title="procgame.dmd.GroupedLayer"><tt class="xref py py-class docutils literal"><span class="pre">GroupedLayer</span></tt></a>: Composites the output of multiple Layer subclasses into one common output.  This can be used to create complicated displays with numerous subcomponents.</li>
<li><a class="reference internal" href="ref/dmd.html#procgame.dmd.ScriptedLayer" title="procgame.dmd.ScriptedLayer"><tt class="xref py py-class docutils literal"><span class="pre">ScriptedLayer</span></tt></a>: Runs a simple &#8220;script&#8221; (dictionary) to display a sequence of layers, showing each layer for a specified amount of time.</li>
</ul>
</div></blockquote>
<p><tt class="xref py py-class docutils literal"><span class="pre">DisplayController</span></tt> checks for an attribute on each <tt class="xref py py-class docutils literal"><span class="pre">Mode</span></tt> class called <tt class="xref py py-attr docutils literal"><span class="pre">layer</span></tt>.  If the mode has a layer, the <tt class="xref py py-meth docutils literal"><span class="pre">next_frame()</span></tt> from that layer is used; otherwise it is ignored.  Let&#8217;s add a layer to an example mode:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">HurryUpMode</span><span class="p">(</span><span class="n">game</span><span class="o">.</span><span class="n">Mode</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">HurryUpMode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">priority</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">layer</span> <span class="o">=</span> <span class="n">dmd</span><span class="o">.</span><span class="n">TextLayer</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">128</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">font</span><span class="o">=</span><span class="n">my_font</span><span class="p">,</span> <span class="n">justify</span><span class="o">=</span><span class="s">&quot;center&quot;</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">update_countdown_display</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seconds</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%d</span><span class="s"> seconds&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">seconds</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="animations-frames-and-fonts">
<h3>Animations, Frames, and Fonts<a class="headerlink" href="#animations-frames-and-fonts" title="Permalink to this headline">¶</a></h3>
<p><em>To be written.</em></p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">pyprocgame Manual</a><ul>
<li><a class="reference internal" href="#prerequisites">Prerequisites</a></li>
<li><a class="reference internal" href="#what-s-in-pyprocgame">What&#8217;s In pyprocgame</a></li>
<li><a class="reference internal" href="#what-s-in-a-pyprocgame-game">What&#8217;s in a pyprocgame Game?</a></li>
<li><a class="reference internal" href="#onward-to-deeper-rulesets">Onward to Deeper Rulesets</a></li>
<li><a class="reference internal" href="#modes-and-the-modequeue">Modes and the ModeQueue</a><ul>
<li><a class="reference internal" href="#mode-management">Mode Management</a></li>
<li><a class="reference internal" href="#other-mode-features">Other Mode Features</a><ul>
<li><a class="reference internal" href="#timed-switch-handlers">Timed Switch Handlers</a></li>
<li><a class="reference internal" href="#scheduling-delayed-method-calls">Scheduling Delayed Method Calls</a></li>
<li><a class="reference internal" href="#mode-status-methods">Mode Status Methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#thoughts-on-planning-and-design-of-modes">Thoughts on Planning and Design of Modes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#drivers">Drivers</a></li>
<li><a class="reference internal" href="#configuration-files">Configuration Files</a><ul>
<li><a class="reference internal" href="#machine-configuration-files">Machine Configuration Files</a></li>
<li><a class="reference internal" href="#system-configuration-files">System Configuration Files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dot-matrix-display-dmd-control">Dot Matrix Display (DMD) Control</a><ul>
<li><a class="reference internal" href="#pyprocgame-display-architecture">pyprocgame Display Architecture</a></li>
<li><a class="reference internal" href="#animations-frames-and-fonts">Animations, Frames, and Fonts</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="install.html"
                        title="previous chapter">Installation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="ref-index.html"
                        title="next chapter">procgame Module Reference</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/manual.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="ref-index.html" title="procgame Module Reference"
             >next</a> |</li>
        <li class="right" >
          <a href="install.html" title="Installation"
             >previous</a> |</li>
        <li><a href="index.html">pyprocgame  documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010-2014, Adam Preble &amp; Gerry Stellenberg.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>